name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop

jobs:
  build-and-test:
    name: CI/CD Pipeline
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configurar Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Run tests
        id: run-tests
        run: npm run test -- --no-watch --no-progress --browsers=ChromeHeadlessCI --code-coverage
        continue-on-error: true

      - name: Generate CI Summary (tests + coverage)
        uses: actions/github-script@v6
        env:
          TEST_OUTCOME: ${{ steps.run-tests.outcome }}
        with:
          script: |
            const fs = require('fs');
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;

            // Header
            fs.appendFileSync(summaryPath, '# üìä Test & Coverage Report\n\n');

            // Tests section
            const testsPassed = (process.env.TEST_OUTCOME === 'success');
            const testIcon = testsPassed ? '‚úÖ' : '‚ùå';
            const testStatus = testsPassed ? 'Passed' : 'Failed';

            // Read test results JSON
            const testResultsFile = 'coverage/proyectoFinal/test-results.json';
            let testDetails = null;
            if (fs.existsSync(testResultsFile)) {
              try {
                const testResultsContent = fs.readFileSync(testResultsFile, 'utf8');
                testDetails = JSON.parse(testResultsContent);
              } catch (e) {
                console.log('Error parsing test results:', e);
              }
            }

            // Display test summary
            if (testDetails && testDetails.result) {
              const totalTests = testDetails.result.total || 0;
              const passedTests = testDetails.result.success || 0;
              const failedTests = testDetails.result.failed || 0;
              const skippedTests = testDetails.result.skipped || 0;

              fs.appendFileSync(summaryPath, `## ${testIcon} Tests: ${testStatus}\n\n`);
              fs.appendFileSync(summaryPath, `**Total:** ${totalTests} | `);
              fs.appendFileSync(summaryPath, `**Passed:** ‚úÖ ${passedTests} | `);
              fs.appendFileSync(summaryPath, `**Failed:** ‚ùå ${failedTests} | `);
              fs.appendFileSync(summaryPath, `**Skipped:** ‚è≠Ô∏è ${skippedTests}\n\n`);

              // Show individual test results
              if (testDetails.result.suites && testDetails.result.suites.length > 0) {
                fs.appendFileSync(summaryPath, '### üìã Test Details\n\n');

                for (const suite of testDetails.result.suites) {
                  if (suite.suite && suite.suite.length > 0) {
                    fs.appendFileSync(summaryPath, `#### ${suite.suite.join(' > ')}\n\n`);
                  }

                  if (suite.tests && suite.tests.length > 0) {
                    for (const test of suite.tests) {
                      const testIcon = test.success ? '‚úÖ' : test.skipped ? '‚è≠Ô∏è' : '‚ùå';
                      const testName = test.description || 'Unknown test';
                      const duration = test.time ? ` (${test.time}ms)` : '';

                      fs.appendFileSync(summaryPath, `${testIcon} ${testName}${duration}\n`);

                      // Show error details for failed tests
                      if (!test.success && !test.skipped && test.log && test.log.length > 0) {
                        fs.appendFileSync(summaryPath, '```\n');
                        for (const log of test.log) {
                          fs.appendFileSync(summaryPath, log + '\n');
                        }
                        fs.appendFileSync(summaryPath, '```\n');
                      }
                    }
                    fs.appendFileSync(summaryPath, '\n');
                  }
                }
              }
            } else {
              fs.appendFileSync(summaryPath, `## ${testIcon} Tests: ${testStatus}\n\n`);
              fs.appendFileSync(summaryPath, `_Test details not available_\n\n`);
            }

            // Coverage section
            const covFile = 'coverage/proyectoFinal/lcov.info';
            if (fs.existsSync(covFile)) {
              const s = fs.readFileSync(covFile, 'utf8');

              // Parse all metrics from lcov.info
              let totalLines = 0, hitLines = 0;
              let totalFunctions = 0, hitFunctions = 0;
              let totalBranches = 0, hitBranches = 0;

              const lines = s.split('\n');
              for (const line of lines) {
                if (line.startsWith('LF:')) totalLines += parseInt(line.substring(3));
                else if (line.startsWith('LH:')) hitLines += parseInt(line.substring(3));
                else if (line.startsWith('FNF:')) totalFunctions += parseInt(line.substring(4));
                else if (line.startsWith('FNH:')) hitFunctions += parseInt(line.substring(4));
                else if (line.startsWith('BRF:')) totalBranches += parseInt(line.substring(4));
                else if (line.startsWith('BRH:')) hitBranches += parseInt(line.substring(4));
              }

              // Calculate percentages
              const linesPct = totalLines ? ((hitLines / totalLines) * 100).toFixed(2) : 'N/A';
              const funcsPct = totalFunctions ? ((hitFunctions / totalFunctions) * 100).toFixed(2) : 'N/A';
              const branchesPct = totalBranches ? ((hitBranches / totalBranches) * 100).toFixed(2) : 'N/A';

              // Overall coverage (based on lines)
              const overallPct = parseFloat(linesPct);
              const coverageIcon = overallPct >= 80 ? 'üü¢' : overallPct >= 60 ? 'üü°' : 'üî¥';

              fs.appendFileSync(summaryPath, `## ${coverageIcon} Code Coverage: ${linesPct}%\n\n`);
              fs.appendFileSync(summaryPath, '| Metric | Coverage | Covered | Total |\n');
              fs.appendFileSync(summaryPath, '|--------|----------|---------|-------|\n');
              fs.appendFileSync(summaryPath, `| **Lines** | ${linesPct}% | ${hitLines} | ${totalLines} |\n`);
              fs.appendFileSync(summaryPath, `| **Functions** | ${funcsPct}% | ${hitFunctions} | ${totalFunctions} |\n`);
              fs.appendFileSync(summaryPath, `| **Branches** | ${branchesPct}% | ${hitBranches} | ${totalBranches} |\n`);
              fs.appendFileSync(summaryPath, '\n');

              // Coverage bar
              const barLength = 20;
              const filledLength = Math.round((overallPct / 100) * barLength);
              const emptyLength = barLength - filledLength;
              const bar = '‚ñà'.repeat(filledLength) + '‚ñë'.repeat(emptyLength);
              fs.appendFileSync(summaryPath, `### Coverage Bar\n\`${bar}\` ${linesPct}%\n\n`);
            } else {
              fs.appendFileSync(summaryPath, `## ‚ùå Coverage Report Not Found\n\n`);
              fs.appendFileSync(summaryPath, `Could not find coverage file at: \`${covFile}\`\n\n`);
            }

#      - name: Upload coverage to Codecov
#        if: success()
#        uses: codecov/codecov-action@v3
#        with:
#          fail_ci_if_error: false
#          files: ./coverage/final-project-web/lcov.info

#  deploy-staging:
#    needs: build-and-test
#    if: github.ref == 'refs/heads/develop'
#    runs-on: ubuntu-latest
#
#    steps:
#      - name: Checkout c√≥digo
#        uses: actions/checkout@v4
#
#      - name: Deploy a Staging
#        run: |
#          echo "üöÄ Desplegando a ambiente de Staging..."
#          # Aqu√≠ puedes agregar tus comandos de deploy a staging
#          # Por ejemplo: npm run deploy:staging
#
#      - name: Notificar deploy de Staging
#        run: echo "‚úÖ Deploy a Staging completado"
#
#  deploy-production:
#    needs: build-and-test
#    if: github.ref == 'refs/heads/main'
#    runs-on: ubuntu-latest

#    steps:
#      - name: Checkout c√≥digo
#        uses: actions/checkout@v4
#
#      - name: Deploy a Production
#        run: |
#          echo "üöÄ Desplegando a ambiente de Producci√≥n..."
#          # Aqu√≠ puedes agregar tus comandos de deploy a producci√≥n
#          # Por ejemplo: npm run deploy:prod
#
#      - name: Notificar deploy de Production
#        run: echo "‚úÖ Deploy a Production completado"
#
#      - name: Crear Release Tag
#        if: success()
#        uses: actions/github-script@v7
#        with:
#          script: |
#            const date = new Date().toISOString().split('T')[0];
#            const tagName = `release-${date}-${context.runNumber}`;
#
#            github.rest.git.createRef({
#              owner: context.repo.owner,
#              repo: context.repo.repo,
#              ref: `refs/tags/${tagName}`,
#              sha: context.sha
#            });
