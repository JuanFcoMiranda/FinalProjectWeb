name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop

jobs:
  build-and-test:
    name: CI/CD Pipeline
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configurar Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Run tests
        id: run-tests
        run: npm run test -- --no-watch --no-progress --browsers=ChromeHeadlessCI --code-coverage
        continue-on-error: true

      - name: Generate CI Summary (tests + coverage)
        uses: actions/github-script@v6
        env:
          TEST_OUTCOME: ${{ steps.run-tests.outcome }}
        with:
          script: |
            const fs = require('fs');
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;

            // Header
            fs.appendFileSync(summaryPath, '# üìä Test & Coverage Report\n\n');

            // Tests section
            const testsPassed = (process.env.TEST_OUTCOME === 'success');
            const testIcon = testsPassed ? '‚úÖ' : '‚ùå';
            const testStatus = testsPassed ? 'Passed' : 'Failed';

            // Read test results JSON
            const testResultsFile = 'coverage/proyectoFinal/test-results.json';
            let testDetails = null;
            if (fs.existsSync(testResultsFile)) {
              try {
                const testResultsContent = fs.readFileSync(testResultsFile, 'utf8');
                testDetails = JSON.parse(testResultsContent);
              } catch (e) {
                console.log('Error parsing test results:', e);
              }
            }

            // Display test summary
            if (testDetails && testDetails.summary) {
              const totalTests = testDetails.summary.success + testDetails.summary.failed + testDetails.summary.skipped;
              const passedTests = testDetails.summary.success || 0;
              const failedTests = testDetails.summary.failed || 0;
              const skippedTests = testDetails.summary.skipped || 0;

              fs.appendFileSync(summaryPath, `## ${testIcon} Tests: ${testStatus}\n\n`);
              fs.appendFileSync(summaryPath, `**Total:** ${totalTests} | `);
              fs.appendFileSync(summaryPath, `**Passed:** ‚úÖ ${passedTests} | `);
              fs.appendFileSync(summaryPath, `**Failed:** ‚ùå ${failedTests} | `);
              fs.appendFileSync(summaryPath, `**Skipped:** ‚è≠Ô∏è ${skippedTests}\n\n`);

              // Show individual test results in a table
              if (testDetails.result) {
                fs.appendFileSync(summaryPath, '### üìã Test Details\n\n');

                // Create table header
                fs.appendFileSync(summaryPath, '| Suite | Test | Status | Time |\n');
                fs.appendFileSync(summaryPath, '|-------|------|--------|------|\n');

                // Collect all tests
                const allTests = [];
                for (const browserId in testDetails.result) {
                  const tests = testDetails.result[browserId];
                  for (const test of tests) {
                    allTests.push(test);
                  }
                }

                // Display tests in table format
                for (const test of allTests) {
                  const suiteName = test.suite.join(' > ') || 'Uncategorized';
                  const testIcon = test.success ? '‚úÖ' : test.skipped ? '‚è≠Ô∏è' : '‚ùå';
                  const testName = test.description || 'Unknown test';
                  const duration = test.time ? `${test.time}ms` : '-';

                  fs.appendFileSync(summaryPath, `| ${suiteName} | ${testName} | ${testIcon} | ${duration} |\n`);
                }

                fs.appendFileSync(summaryPath, '\n');

                // Show error details for failed tests (if any)
                const failedTests = allTests.filter(t => !t.success && !t.skipped);
                if (failedTests.length > 0) {
                  fs.appendFileSync(summaryPath, '### ‚ùå Failed Test Details\n\n');
                  for (const test of failedTests) {
                    const suiteName = test.suite.join(' > ') || 'Uncategorized';
                    const testName = test.description || 'Unknown test';
                    fs.appendFileSync(summaryPath, `#### ${suiteName} > ${testName}\n\n`);
                    if (test.log && test.log.length > 0) {
                      fs.appendFileSync(summaryPath, '```\n');
                      for (const log of test.log) {
                        fs.appendFileSync(summaryPath, log + '\n');
                      }
                      fs.appendFileSync(summaryPath, '```\n\n');
                    }
                  }
                }
              }
            } else {
              fs.appendFileSync(summaryPath, `## ${testIcon} Tests: ${testStatus}\n\n`);
              fs.appendFileSync(summaryPath, `_Test details not available_\n\n`);
            }

            // Coverage section
            const covFile = 'coverage/proyectoFinal/lcov.info';
            if (fs.existsSync(covFile)) {
              const s = fs.readFileSync(covFile, 'utf8');

              // Parse all metrics from lcov.info
              let totalLines = 0, hitLines = 0;
              let totalFunctions = 0, hitFunctions = 0;
              let totalBranches = 0, hitBranches = 0;

              const lines = s.split('\n');
              for (const line of lines) {
                if (line.startsWith('LF:')) totalLines += parseInt(line.substring(3));
                else if (line.startsWith('LH:')) hitLines += parseInt(line.substring(3));
                else if (line.startsWith('FNF:')) totalFunctions += parseInt(line.substring(4));
                else if (line.startsWith('FNH:')) hitFunctions += parseInt(line.substring(4));
                else if (line.startsWith('BRF:')) totalBranches += parseInt(line.substring(4));
                else if (line.startsWith('BRH:')) hitBranches += parseInt(line.substring(4));
              }

              // Calculate percentages
              const linesPct = totalLines ? ((hitLines / totalLines) * 100).toFixed(2) : 'N/A';
              const funcsPct = totalFunctions ? ((hitFunctions / totalFunctions) * 100).toFixed(2) : 'N/A';
              const branchesPct = totalBranches ? ((hitBranches / totalBranches) * 100).toFixed(2) : 'N/A';

              // Overall coverage (based on lines)
              const overallPct = parseFloat(linesPct);
              const coverageIcon = overallPct >= 80 ? 'üü¢' : overallPct >= 60 ? 'üü°' : 'üî¥';

              fs.appendFileSync(summaryPath, `## ${coverageIcon} Code Coverage: ${linesPct}%\n\n`);
              fs.appendFileSync(summaryPath, '| Metric | Coverage | Covered | Total |\n');
              fs.appendFileSync(summaryPath, '|--------|----------|---------|-------|\n');
              fs.appendFileSync(summaryPath, `| **Lines** | ${linesPct}% | ${hitLines} | ${totalLines} |\n`);
              fs.appendFileSync(summaryPath, `| **Functions** | ${funcsPct}% | ${hitFunctions} | ${totalFunctions} |\n`);
              fs.appendFileSync(summaryPath, `| **Branches** | ${branchesPct}% | ${hitBranches} | ${totalBranches} |\n`);
              fs.appendFileSync(summaryPath, '\n');

              // Coverage bar with elegant styling
              fs.appendFileSync(summaryPath, `### üìà Coverage Progress\n\n`);

              // Choose color and emoji based on coverage percentage
              let statusBadge = '';
              let statusEmoji = '';
              if (overallPct >= 80) {
                statusBadge = '![Coverage](https://img.shields.io/badge/coverage-excellent-brightgreen)';
                statusEmoji = 'üéâ';
              } else if (overallPct >= 60) {
                statusBadge = '![Coverage](https://img.shields.io/badge/coverage-good-yellow)';
                statusEmoji = 'üëç';
              } else if (overallPct >= 40) {
                statusBadge = '![Coverage](https://img.shields.io/badge/coverage-needs_improvement-orange)';
                statusEmoji = '‚ö†Ô∏è';
              } else {
                statusBadge = '![Coverage](https://img.shields.io/badge/coverage-low-red)';
                statusEmoji = 'üî¥';
              }

              // Create a visual bar using block characters
              const totalBlocks = 30;
              const filledBlocks = Math.round((overallPct / 100) * totalBlocks);
              const emptyBlocks = totalBlocks - filledBlocks;

              // Use Unicode block characters for smooth gradient
              const fullBlock = '‚ñà';
              const emptyBlock = '‚ñë';
              const visualBar = fullBlock.repeat(filledBlocks) + emptyBlock.repeat(emptyBlocks);

              fs.appendFileSync(summaryPath, `<table><tr><td>\n\n`);
              fs.appendFileSync(summaryPath, `${statusEmoji} **${linesPct}%** Lines Covered\n\n`);
              fs.appendFileSync(summaryPath, '```\n');
              fs.appendFileSync(summaryPath, `${visualBar}\n`);
              fs.appendFileSync(summaryPath, '```\n\n');
              fs.appendFileSync(summaryPath, `</td></tr></table>\n\n`);
            } else {
              fs.appendFileSync(summaryPath, `## ‚ùå Coverage Report Not Found\n\n`);
              fs.appendFileSync(summaryPath, `Could not find coverage file at: \`${covFile}\`\n\n`);
            }

#      - name: Upload coverage to Codecov
#        if: success()
#        uses: codecov/codecov-action@v3
#        with:
#          fail_ci_if_error: false
#          files: ./coverage/final-project-web/lcov.info

#  deploy-staging:
#    needs: build-and-test
#    if: github.ref == 'refs/heads/develop'
#    runs-on: ubuntu-latest
#
#    steps:
#      - name: Checkout c√≥digo
#        uses: actions/checkout@v4
#
#      - name: Deploy a Staging
#        run: |
#          echo "üöÄ Desplegando a ambiente de Staging..."
#          # Aqu√≠ puedes agregar tus comandos de deploy a staging
#          # Por ejemplo: npm run deploy:staging
#
#      - name: Notificar deploy de Staging
#        run: echo "‚úÖ Deploy a Staging completado"
#
#  deploy-production:
#    needs: build-and-test
#    if: github.ref == 'refs/heads/main'
#    runs-on: ubuntu-latest

#    steps:
#      - name: Checkout c√≥digo
#        uses: actions/checkout@v4
#
#      - name: Deploy a Production
#        run: |
#          echo "üöÄ Desplegando a ambiente de Producci√≥n..."
#          # Aqu√≠ puedes agregar tus comandos de deploy a producci√≥n
#          # Por ejemplo: npm run deploy:prod
#
#      - name: Notificar deploy de Production
#        run: echo "‚úÖ Deploy a Production completado"
#
#      - name: Crear Release Tag
#        if: success()
#        uses: actions/github-script@v7
#        with:
#          script: |
#            const date = new Date().toISOString().split('T')[0];
#            const tagName = `release-${date}-${context.runNumber}`;
#
#            github.rest.git.createRef({
#              owner: context.repo.owner,
#              repo: context.repo.repo,
#              ref: `refs/tags/${tagName}`,
#              sha: context.sha
#            });
